---
import { Image } from "astro:assets";

const { project } = Astro.props;
---

<div
  class="relative z-10 flex flex-col gap-4 bg-white [&:not(:first-child)]:pt-30 pt-10"
>
  <h2
    class="text-8xl max-w-[1450px] mx-auto uppercase text-center tracking-tighter leading-[85%] text-balance sticky top-4 py-10 mb-10 project-title"
  >
    {project.title}
    <div
      class="absolute top-0 left-0 size-2 bg-gray-900 rounded-[2px] corner-element"
    >
    </div>
    <div
      class="absolute top-0 right-0 size-2 bg-gray-900 rounded-[2px] corner-element"
    >
    </div>
    <div
      class="absolute bottom-0 left-0 size-2 bg-gray-900 rounded-[2px] corner-element"
    >
    </div>
    <div
      class="absolute bottom-0 right-0 size-2 bg-gray-900 rounded-[2px] corner-element"
    >
    </div>
  </h2>
  <div class="bg-white z-20" id="project-images">
    <div class="flex gap-2 px-2 pb-5 pt-2 w-full relative h-full">
      {
        project.images &&
          project.images.map(
            (
              asset: {
                src: string;
                isVideo: boolean;
                aspectRatio: string;
                isHorizontal?: boolean;
              },
              index: number
            ) => {
              return (
                <div
                  class={
                    asset.isHorizontal
                      ? `relative w-full h-auto ${asset.aspectRatio} cursor-pointer lightbox-trigger`
                      : `relative w-auto cursor-pointer lightbox-trigger`
                  }
                  data-index={index}
                >
                  {asset.isVideo ? (
                    <video
                      src={asset.src}
                      class="relative size-full object-cover"
                      autoplay
                      muted
                      loop
                      playsinline
                    />
                  ) : (
                    <Image
                      src={asset.src}
                      alt=""
                      class="relative size-full object-cover"
                      inferSize
                    />
                  )}
                </div>
              );
            }
          )
      }
    </div>
    <div class="mx-auto flex justify-between z-0 items-stretch sticky bottom-0">
      <div class="w-1/3 pt-1 text-sm text-balance flex overflow-hidden">
        <div class="bg-white uppercase text-[10px] tracking-wider p-1">
          <span class="translate-y-[1px]"> [ Ã€ Propos ] </span>
        </div>
        <p class="text-gray-500 p-1 flex-1 bg-white text-[12px] text-balance">
          {project.description}
        </p>
      </div>
      <div class="pt-1 text-sm text-balance flex overflow-hidden">
        <!-- <div -->
          class="flex flex-col bg-white uppercase text-[10px] tracking-wider p-1"
        >
          <span class="translate-y-[1px]"> [ Stack ] </span>
        </div>
        <div class="bg-white flex flex-wrap gap-1 p-1 flex-1">
          {
            project.stack &&
              project.stack.map((tech: string, index: number) => (
                <span class="text-[12px]  text-gray-500">
                  {index < project.stack.length - 1 ? `${tech}, ` : `${tech}.`}
                </span>
              ))
          }
        </div>
      </div>
    </div>
  </div>
  <!-- Lightbox overlay -->
</div>

<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  gsap.registerPlugin(ScrollTrigger);

  // Get all corner elements
  const cornerElements = document.querySelectorAll(".corner-element");

  // Set initial state - all corners invisible
  gsap.set(cornerElements, { opacity: 0, scale: 0 });

  cornerElements.forEach((element) => {
    const randomDelay = 0.1 + Math.random() * 0.25;

    // Create flicker timeline
    const flickerTimeline = gsap.timeline({
      scrollTrigger: {
        trigger: element.parentElement,
        start: "top 80%", // Start animation when the top of the parent is 80% from the top of viewport
        once: true,
      },
      delay: randomDelay,
    });

    // Add more dramatic flicker effect
    flickerTimeline
      .to(element, { opacity: 1, scale: 1.2, duration: 0.08 })
      .to(element, { opacity: 0, scale: 0.8, duration: 0.04 })
      .to(element, { opacity: 0.9, scale: 1.1, duration: 0.06 })
      .to(element, { opacity: 0.1, scale: 0.9, duration: 0.03 })
      .to(element, { opacity: 1, scale: 1.15, duration: 0.05 })
      .to(element, { opacity: 0.3, scale: 0.85, duration: 0.04 })
      .to(element, { opacity: 0.8, scale: 1.05, duration: 0.06 })
      .to(element, { opacity: 0.2, scale: 0.95, duration: 0.03 })
      .to(element, { opacity: 1, scale: 1, duration: 0.07 });
  });

  // Title flickering effect
  const projectTitles = document.querySelectorAll(".project-title");

  // Set initial state for titles - but don't set opacity to 0 here
  // This allows the fade in/out animation to control opacity after the flicker

  projectTitles.forEach((title) => {
    const titleFlickerTimeline = gsap.timeline({
      scrollTrigger: {
        trigger: title,
        start: "top 80%",
        once: true, // Only play the flicker animation once
      },
    });

    // Create a more subtle flicker for the title text
    titleFlickerTimeline
      .set(title, { opacity: 0 }) // Set initial opacity here instead
      .to(title, { opacity: 0.7, duration: 0.1 })
      .to(title, { opacity: 0.2, duration: 0.05 })
      .to(title, { opacity: 0.9, duration: 0.08 })
      .to(title, { opacity: 0.5, duration: 0.03 })
      .to(title, { opacity: 1, duration: 0.07 })
      .to(title, { opacity: 0.8, duration: 0.02 })
      .to(title, { opacity: 1, duration: 0.06 })
      .to(title, { opacity: 0.6, duration: 0.04 })
      .to(title, { opacity: 1, duration: 0.1 });
  });

  // const projectImages = document.querySelectorAll("#project-images");

  // projectImages.forEach((imagesContainer) => {
  //   // Create timeline for each images container
  //   const projectImagesTimeline = gsap.timeline({
  //     scrollTrigger: {
  //       trigger: imagesContainer,
  //       start: "top 15%", // Start when images are 20% from top of viewport
  //       end: "top 5%", // End when images reach the top of viewport
  //       scrub: true, // Smoothly animate on scroll
  //       once: false, // Allow animation to repeat
  //       toggleActions: "play reverse play reverse", // Play forward when scrolling down, reverse when scrolling up
  //     },
  //   });

  //   // Fade out all titles as images approach the top
  //   // This will only run after the flicker animation has completed
  //   projectTitles.forEach((title) => {
  //     projectImagesTimeline.to(title, {
  //       opacity: 0,
  //       duration: 0.5, // Slightly longer duration for smoother fade
  //       ease: "power2.out", // Smooth easing curve
  //     }); // Remove the 0 position parameter to let animations sequence properly
  //   });
  // });

  // Lightbox functionality
  const lightbox = document.getElementById("lightbox");
  const lightboxContent = document.getElementById("lightbox-content");
  const closeButton = document.getElementById("close-lightbox");
  const triggers = document.querySelectorAll(".lightbox-trigger");

  // Store all media elements for quick access
  const mediaElements: { isVideo: boolean; src: string }[] = [];
  triggers.forEach((trigger, index) => {
    // Store reference to the media element (image or video)
    const mediaElement = trigger.querySelector("img, video");
    mediaElements[index] = {
      isVideo: mediaElement?.tagName === "VIDEO",
      src: mediaElement?.getAttribute("src") ?? "",
    };

    // Add click event to open lightbox
    trigger.addEventListener("click", () => openLightbox(index));
  });

  function openLightbox(index: number) {
    const media = mediaElements[index];

    // Clear previous content
    if (lightboxContent) {
      lightboxContent.innerHTML = "";

      // Create appropriate element based on type
      if (media.isVideo) {
        const video = document.createElement("video");
        video.src = media.src;
        video.classList.add("max-w-full", "max-h-[80vh]", "object-contain");
        video.autoplay = true;
        video.loop = true;
        video.muted = false; // Unmuted in lightbox
        video.controls = true;
        video.playsInline = true;
        lightboxContent.appendChild(video);
      } else {
        const img = document.createElement("img");
        img.src = media.src;
        img.classList.add("max-w-full", "max-h-[80vh]", "object-contain");
        lightboxContent.appendChild(img);
      }

      // Show lightbox
      lightbox?.classList.remove("hidden");

      // Animate in
      gsap.to(lightboxContent, {
        y: 0,
        opacity: 1,
        duration: 0.4,
        ease: "power2.out",
      });
    }
  }

  function closeLightbox() {
    // Animate out
    gsap.to(lightboxContent, {
      y: 20,
      opacity: 0,
      duration: 0.3,
      ease: "power2.in",
      onComplete: () => {
        lightbox?.classList.add("hidden");
        // Stop video if playing
        const video = lightboxContent?.querySelector("video");
        if (video) video.pause();
      },
    });
  }

  // Close lightbox when clicking the close button
  if (closeButton) {
    closeButton.addEventListener("click", closeLightbox);
  }

  // Close lightbox when clicking outside the content
  if (lightbox) {
    lightbox.addEventListener("click", (e) => {
      if (
        e.target === lightbox ||
        e.target === lightbox.querySelector(".bg-black/70")
      ) {
        closeLightbox();
      }
    });
  }

  // Close lightbox with Escape key
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && !lightbox?.classList.contains("hidden")) {
      closeLightbox();
    }
  });
</script>
